package Pseudo;

import java_cup.runtime.*;

parser code {:
public static void main(String args[]) throws Exception {
	SymbolFactory sf = new DefaultSymbolFactory();
	if (args.length==0) 
		new parser(new Scanner(System.in,sf),sf).parse();
	else 
		new parser(new Scanner(new java.io.FileInputStream(args[0]),sf),sf).parse();
	}

:}


non terminal algoritmo, decl_algoritmo, decl_variables, decl_const, decl_sentencias;

programa ::=  decl_algoritmo  decl_variables  decl_const  decl_sentencias;

decl_algoritmo ::= ALGORITMO IDENTIFICADOR;

decl_variables ::= VAR lista_declaraciones;

decl_const ::= CONST lista_declaraciones;

lista_declaraciones ::=	linea_decl lista_declaraciones
			|	linea_decl;

linea_decl ::=  lista_identificadores DOSPUNTOS tipo_dato NUEVALINEA;


lista_identificadores ::= decl_ident COMA lista_identificadores 
	| decl_ident; 

decl_ident ::= 	ident
		|	ident CORCHIZQ tamano CORCHDER;

tamano ::= NUM;

ident ::= IDENTIFICADOR;


tipo_dato ::= ENTERO | REAL  | CARACTER | CADENA | LOGICO;

decl_sentencias ::=  INICIO lista_sentencias FIN;

lista_sentencias ::= sentencia lista_sentencias | {/*Vacio*/};

sentencia ::=  	sent_expr 
		| sent_sel
		| sent_iter 
		| error 
		;

sent_expr ::= 	expr NUEVALINEA
		|	NUEVALINEA
		;

sent_sel	::= 	SI PARENTIZQ expr_simple PARENTDER sentencia 
		|	SI PARENTIZQ expr_simple PARENTDER sentencia SINO sentencia
		;

sent_iter	::=  /*Hacer los ciclos fijados en la especificacion*/

		

expr ::=  	var ASIGNACION expr
	|	expr_simple
	;


var ::= 	ident 
	|	ident CORCHIZQ expr CORCHDER
	|	error
	;

expr_simple ::= expr_aritm oprel expr_aritm
		  |	expr_aritm
		  ;

oprel	::= 	MENOR
	|	MAYOR
	|	MENORIGUAL
	|	MAYORIGUAL
	|	DIFERENTE
	|	IGUAL
	;

expr_aritm ::= 	expr_aritm opsuma termino
		|	termino
		;

opsuma	::=	SUMA
		|	RESTA;

termino	::=	termino opmulti	factor
		|	factor
		;

opmulti	::=	MULTIPLI
		|	DIVISION
		;

factor	::=	PARENTIZQ expr PARENTDER
		|	var
		|	NUM
		;

/*comentario ::= .... HACER*/
/* añadir proced, funciones, sus llamadas. */

/*Debo recordar que las sentencias son hijos de extrema izquierda con hermanos a la derecha*/


stmt        : expr_stmt { $$ = $1; if(debug) printf("regla 14a -> stmt : expr_stmt\n");}
            | cmpd_stmt { $$ = $1; if(debug) printf("regla 14b -> stmt : cmpd_stmt\n");}
            | sel_stmt { $$ = $1; if(debug) printf("regla 14c -> stmt : sel_stmt\n");}
            | iter_stmt  { $$ = $1; if(debug) printf("regla 14d -> stmt : iter_stmt\n");}
            | return_stmt  { $$ = $1; if(debug) printf("regla 14e -> stmt : return_stmt\n");}
            | error { $$ = NULL; if(debug) printf("regla 14f-> stmt : error\n");}


